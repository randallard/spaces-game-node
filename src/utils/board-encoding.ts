/**
 * Minimal Board Encoding/Decoding for URL Sharing
 *
 * Format: [size]|[sequence]
 * Example: 2|2p0p2tG0f
 *
 * See docs/MINIMAL_BOARD_ENCODING.md for full specification
 */

import type { Board, BoardMove, BoardSize, CellContent, Position } from '../types/board';

/**
 * Encode a board into minimal format for URL sharing
 *
 * @param board - The board to encode
 * @returns Encoded string (e.g., "2|2p0p2tG0f")
 */
export function encodeMinimalBoard(board: Board): string {
  const size = board.boardSize;

  // Determine position width based on board size
  const maxPos = size * size - 1;
  const posWidth = maxPos < 10 ? 1 : maxPos < 100 ? 2 : 3;

  const moves = board.sequence.map((move) => {
    if (move.position.row === -1) {
      // Goal position: always use G prefix, no padding
      return `G${move.position.col}${move.type[0]}`;
    } else {
      // Regular position: pad to posWidth
      const pos = move.position.row * size + move.position.col;
      const padded = pos.toString().padStart(posWidth, '0');
      return `${padded}${move.type[0]}`;
    }
  }).join('');

  return `${size}|${moves}`;
}

/**
 * Decode a minimal format string into a Board object
 *
 * @param encoded - The encoded string (e.g., "2|2p0p2tG0f")
 * @returns Decoded Board object
 */
export function decodeMinimalBoard(encoded: string): Board {
  const [sizeStr, seqStr] = encoded.split('|');

  if (!sizeStr || !seqStr) {
    throw new Error('Invalid encoded board format: missing size or sequence');
  }

  const boardSize = parseInt(sizeStr) as BoardSize;

  if (isNaN(boardSize) || boardSize < 2 || boardSize > 99) {
    throw new Error(`Invalid board size: ${sizeStr}`);
  }

  // Determine position width based on board size
  const maxPos = boardSize * boardSize - 1;
  const posWidth = maxPos < 10 ? 1 : maxPos < 100 ? 2 : 3;

  // Parse sequence
  const sequence: BoardMove[] = [];
  let i = 0;
  let order = 1;

  while (i < seqStr.length) {
    let position: Position;
    let type: 'piece' | 'trap' | 'final';

    // Handle goal position (G0, G1, G2, etc.)
    if (seqStr[i] === 'G') {
      if (i + 2 >= seqStr.length) {
        throw new Error(`Invalid goal position at index ${i}`);
      }
      const colChar = seqStr[i + 1];
      if (!colChar) {
        throw new Error(`Missing goal column at index ${i + 1}`);
      }
      const col = parseInt(colChar);
      if (isNaN(col)) {
        throw new Error(`Invalid goal column at index ${i + 1}`);
      }
      position = { row: -1, col };
      const typeChar = seqStr[i + 2];
      if (typeChar !== 'p' && typeChar !== 't' && typeChar !== 'f') {
        throw new Error(`Invalid move type '${typeChar}' at index ${i + 2}`);
      }
      type = typeChar === 'p' ? 'piece' : typeChar === 't' ? 'trap' : 'final';
      i += 3;
    } else {
      // Regular grid position: read posWidth digits
      if (i + posWidth >= seqStr.length) {
        throw new Error(`Invalid position at index ${i}: not enough characters`);
      }
      const posStr = seqStr.substring(i, i + posWidth);
      const pos = parseInt(posStr);
      if (isNaN(pos)) {
        throw new Error(`Invalid position value '${posStr}' at index ${i}`);
      }
      position = {
        row: Math.floor(pos / boardSize),
        col: pos % boardSize,
      };
      const typeChar = seqStr[i + posWidth];
      if (typeChar !== 'p' && typeChar !== 't' && typeChar !== 'f') {
        throw new Error(`Invalid move type '${typeChar}' at index ${i + posWidth}`);
      }
      type = typeChar === 'p' ? 'piece' : typeChar === 't' ? 'trap' : 'final';
      i += posWidth + 1; // Skip position digits + type char
    }

    sequence.push({ position, type, order: order++ });
  }

  // Derive grid from sequence
  const grid = deriveGridFromSequence(sequence, boardSize);

  // Generate client-side data
  const id = crypto.randomUUID();
  const thumbnail = ''; // Will be generated by the rendering system
  const createdAt = Date.now();

  return {
    id,
    name: 'Shared Board',
    boardSize,
    grid,
    sequence,
    thumbnail,
    createdAt,
  };
}

/**
 * Derive grid from sequence by applying moves in order.
 * Last move at each position determines the cell content.
 *
 * @param sequence - Array of board moves
 * @param size - Board size
 * @returns 2D grid of cell contents
 */
export function deriveGridFromSequence(
  sequence: BoardMove[],
  size: number
): CellContent[][] {
  // Initialize empty grid
  const grid: CellContent[][] = Array(size)
    .fill(null)
    .map(() => Array(size).fill('empty'));

  // Apply each move (later moves overwrite earlier ones)
  for (const move of sequence) {
    // Skip goal positions (row -1)
    if (move.position.row === -1) continue;

    const { row, col } = move.position;

    // Validate position is within bounds
    if (row < 0 || row >= size || col < 0 || col >= size) {
      throw new Error(`Position (${row}, ${col}) is out of bounds for ${size}x${size} board`);
    }

    const gridRow = grid[row];
    if (!gridRow) {
      throw new Error(`Grid row ${row} is undefined`);
    }

    if (move.type === 'piece') {
      gridRow[col] = 'piece';
    } else if (move.type === 'trap') {
      gridRow[col] = 'trap';
    }
    // 'final' type doesn't affect the grid (it's a goal state)
  }

  return grid;
}

/**
 * Validate that a board can be properly encoded and decoded
 *
 * @param board - The board to validate
 * @returns True if valid, throws error if invalid
 */
export function validateBoardForEncoding(board: Board): boolean {
  if (!board.sequence || board.sequence.length === 0) {
    throw new Error('Board must have at least one move in sequence');
  }

  if (board.boardSize < 2 || board.boardSize > 99) {
    throw new Error('Board size must be between 2 and 99');
  }

  // Validate sequence ordering
  for (let i = 0; i < board.sequence.length; i++) {
    const move = board.sequence[i];
    if (!move) {
      throw new Error(`Sequence move at index ${i} is undefined`);
    }
    if (move.order !== i + 1) {
      throw new Error(`Sequence order mismatch at index ${i}: expected ${i + 1}, got ${move.order}`);
    }
  }

  return true;
}
